・step1 文字（BOMを除去、charに変換、改行を統一、行番号/列番号の管理）
    Vec<u8> -> Vec<Char>

    fn read() -> Option<char, (u64, u64)>
        charに変換する。
        BOMを除去する。
    fn mark() -> usize
    fn reset

・step2 ユニット（改行（行列）、インデント、アンインデント、文字（行列）、EOF（行列））
    Vec<Char> -> Vec<Unit>

    SourceUnitStream
        fn read() -> Unit
        fn mark() -> Mark(u64, indent_level?)
        fn reset()

    行末の空白を除去する。
    
・step3 構造化ソース（ブロック、ブロックタグ、ブロックタグヘッダー、インラインタグ、空白行、段落、テキスト）
    Vec<Unit> -> Block

	parse_xxx関数の共通仕様
	・Ok, Mismatch, Warning, Errorのいずれかを返す。
	・Okになった時、読み込み位置は最後に消費したユニットの次にある。
    ・Mismatchになった時、読み込み位置は関数の呼び出し前に戻っている。
    ・Warningを返すのはその要素を書こうとしていると判断できて、それでも途中で間違っている時。
    ・Errorはあり得ない状況を検出した時に発生するもので、バグがなければ出ない。
    
    ・どのような状態で呼ばれるのか。
    ・何を要素に持つのか。
    ・どこまで消費するのか。
    ・何が出現したら終わるのか。
    ・どうなったらミスマッチ、警告、エラーになるか。
    
    ブロック
    ・開始がブロック開始でなければミスマッチ。
    ・以下を繰り返し。
        ・ブロック終了ならパース成功。
        ・EOFならエラー。
        ・ブロック、ブロックタグ、段落、空白行の順でパースを試行して要素を追加していく。
            段落と空白行のどちらかはパースできるはずなので何もパースできなかったらエラー。
    
    ブロックタグ
    ・タグをパースする。成功以外なら伝播する。
    ・属性リストをパースする。成功なら保持、ミスマッチなら属性なし、それ以外なら伝播する。
    ・次が空白なら読み飛ばしてブロックタグヘッダーをパースして保持する。
        空白があったということはそれ以降に空白以外があるので成功するはず。
        ミスマッチ
    ・要素としてタグ名、属性、ヘッダー、ブロックを持つ。
    ・消費するユニットや終わりは構成要素が決める。
    ・ミスマッチの条件は、
        開始がコロンではない。
        タグ名がルールに反している。
    ・エラーの条件は、
        構成要素のパースでエラーになった時。
        
    ブロックタグヘッダー
    ・開始位置はタグ名に続く空白の1文字後。
    ・要素はインラインタグと文字列。
    ・改行かEOFで終了。
    ・改行まで消費する。
    ・要素が1つもなければミスマッチ。
    ・インデント、アンインデントがあったらエラー。
    
    段落
    ・行頭で呼ばれる。
    ・インラインタグとテキストを要素に持つ。
    ・最後の改行まで消費する。
    ・EOFで終了。空白行が出現したらその直前で終了。
    ・要素がなければ（開始がEOF）ミスマッチ。
    ・インデント、アンインデントでエラー。
    
    インラインタグ
    ・コロンのある位置で呼ばれる。
        通常は呼び出し元が確認してから呼ぶが、パース関数でも確認する。
    ・"}"まで消費する。
    ・タグ名がミスマッチになったらミスマッチ。
    ・要素のパースでエラーになったらエラー。
    ・内容は必須なのでなければエラー。
    
    インラインタグ内容
    ・"{"の位置で呼ばれる。
    ・"}"が出現したら終了。
    ・インラインタグ、テキストを要素とする。
    ・"{"で始まらなければミスマッチ。
    ・インデント、アンインデント、EOFが出現したらエラー。
    

    fn parse_block
        UnIndentかEOFがあったらパース終了。
        Indentがあったら別のブロックをパース開始。
        ':'から始まっていたらブロックタグをパース開始。
        それ以外なら段落をパース開始。

    fn parse_block_tag
        最初が':'でなければ失敗。
        タグ名をパースできなければ失敗。
        属性をパース、失敗したら属性なしだがパースエラーならタグもエラー。
        ':'だったらブロックタグをパース。失敗したらパースエラー。
        空白だったらヘッダー、改行だったら内容パース、それ以外ならパースエラー。

    fn parse_block_tag_contents
        NewLineは無視。
        Indentがあったらそこからブロックをパースする。
        EOFなら内容なしでパース終了。
        UnIndentかそれ以外なら内容パース失敗なので開始まで戻る。
        
    fn parse_inline_tag

    fn parse_paragraph

・step5 DOM
    改行モードなどのために属性が必要で、それを保持するコンテキストを作る。

    trait Node {}

    struct Element {
        name: String,
        attributes: HashMap<String,String>,
        contents: Vec<Box<dyn Node>>,
    }

    struct Text {
        contents: String,
    }

・step6 HTML
