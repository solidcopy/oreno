・step1 文字（BOMを除去、charに変換、改行を統一、行番号/列番号の管理）
    Vec<u8> -> Vec<Char>

    fn read() -> Option<char, (u64, u64)>
        charに変換する。
        BOMを除去する。
    fn mark() -> usize
    fn reset

・step2 ユニット（改行（行列）、インデント、アンインデント、文字（行列）、EOF（行列））
    Vec<Char> -> Vec<Unit>

    行末の空白を除去する。
    
・step3 構造化ソース（ブロック、ブロックタグ、ブロックタグヘッダー、インラインタグ、空白行、段落、テキスト）
    Vec<Unit> -> Block

    テスト
    block_tag
    
    :bt
        xxx
    
    zzz
    
    の時、ブロックタグは空白行の前まで、xxxの後の改行までを消費するのが正しい気がする。
    だが、ブロックをパースする時に空白行ではパースを終了しないので、zzzの前の空白行まで消費する。
    それでいいのか？
    タグがcode-blockだったとして、ソースコードを表示する枠の最後に空白行が挿入されるのは見栄えが悪い。
    
    ブロックのパースを直すべきか。
    そうだとしてどういうルールにすればいい？
    出現した時点では要素に含めていいのか確定しないのは空白行だけか。そう。
    
    空白行が出現した時に、最初の空白行にマーカーをおいてカウントを開始する。
    空白行以外が出現したらカウントの分だけ空白行を要素に追加する。
    出現しなかったらリセットしてパース終了。
    
    警告の内容は見直しが必要。

    警告をローカライズ可能にする。

    警告に位置情報を追加。

・step5 DOM
    改行モードなどのために属性が必要で、それを保持するコンテキストを作る。

    trait Node {}

    struct Element {
        name: String,
        attributes: HashMap<String,String>,
        contents: Vec<Box<dyn Node>>,
    }

    struct Text {
        contents: String,
    }

・step6 HTML
