・step1 文字（BOMを除去、charに変換、改行を統一、行番号/列番号の管理）
    Vec<u8> -> Vec<Char>

    fn read() -> Option<char, (u64, u64)>
        charに変換する。
        BOMを除去する。
    fn mark() -> usize
    fn reset

・step2 ユニット（改行（行列）、インデント、アンインデント、文字（行列）、EOF（行列））
    Vec<Char> -> Vec<Unit>

    行末の空白を除去する。
    
・step3 構造化ソース（ブロック、ブロックタグ、ブロックタグヘッダー、インラインタグ、空白行、段落、テキスト）
    Vec<Unit> -> Block

    ネストの親にrawタグを書けないことを仕様にする。

    タグ名と属性のパースに失敗して不適合
    *属性あり
    *属性なし
    *rawタグ
    *属性の後に不正な文字
    *属性の後で改行
    *属性の後でEOF
    *ネスト
        *属性なし
        *属性あり
        *1つ目がraw
        *2つ目がraw
    *ヘッダーあり
        *改行で終わり
        *EOFで終わり
    *ヘッダーなし
    内容あり
        *ブロック終端で終わり
        EOFで終わり
    *内容なし
    
    インラインタグもネストをテストしていない。

    unit_stream.readの予備忘れ防止のため、peekは参照を返すようにする。
    消費は必ずreadした文字でする。

    警告の内容は見直しが必要。
    警告をローカライズ可能にする。
    警告に位置情報を追加。

・step5 DOM
    改行モードなどのために属性が必要で、それを保持するコンテキストを作る。

    trait Node {}

    struct Element {
        name: String,
        attributes: HashMap<String,String>,
        contents: Vec<Box<dyn Node>>,
    }

    struct Text {
        contents: String,
    }

・step6 HTML
